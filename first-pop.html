<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Pop ãƒ¡ã‚½ãƒƒãƒ‰ - Learning Rust With Entirely Too Many Linked Lists æ—¥æœ¬èªç‰ˆ</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Learning Rust With Entirely Too Many Linked Lists">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">ã‚¤ãƒ³ãƒˆãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³</a></li><li class="chapter-item expanded "><a href="first.html"><strong aria-hidden="true">1.</strong> ã ã‚ãªå®Ÿè£…</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="first-layout.html"><strong aria-hidden="true">1.1.</strong> è¨­è¨ˆ</a></li><li class="chapter-item expanded "><a href="first-new.html"><strong aria-hidden="true">1.2.</strong> New ãƒ¡ã‚½ãƒƒãƒ‰</a></li><li class="chapter-item expanded "><a href="first-ownership.html"><strong aria-hidden="true">1.3.</strong> æ‰€æœ‰æ¨©ã®ã„ã‚ã¯</a></li><li class="chapter-item expanded "><a href="first-push.html"><strong aria-hidden="true">1.4.</strong> Push ãƒ¡ã‚½ãƒƒãƒ‰</a></li><li class="chapter-item expanded "><a href="first-pop.html" class="active"><strong aria-hidden="true">1.5.</strong> Pop ãƒ¡ã‚½ãƒƒãƒ‰</a></li><li class="chapter-item expanded "><a href="first-test.html"><strong aria-hidden="true">1.6.</strong> ãƒ†ã‚¹ãƒˆ</a></li><li class="chapter-item expanded "><a href="first-drop.html"><strong aria-hidden="true">1.7.</strong> Drop ãƒ¡ã‚½ãƒƒãƒ‰</a></li><li class="chapter-item expanded "><a href="first-final.html"><strong aria-hidden="true">1.8.</strong> å‡ºæ¥ä¸ŠãŒã‚Š</a></li></ol></li><li class="chapter-item expanded "><a href="second.html"><strong aria-hidden="true">2.</strong> An Ok Stack</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="second-option.html"><strong aria-hidden="true">2.1.</strong> Option</a></li><li class="chapter-item expanded "><a href="second-generic.html"><strong aria-hidden="true">2.2.</strong> Generic</a></li><li class="chapter-item expanded "><a href="second-peek.html"><strong aria-hidden="true">2.3.</strong> Peek</a></li><li class="chapter-item expanded "><a href="second-into-iter.html"><strong aria-hidden="true">2.4.</strong> IntoIter</a></li><li class="chapter-item expanded "><a href="second-iter.html"><strong aria-hidden="true">2.5.</strong> Iter</a></li><li class="chapter-item expanded "><a href="second-iter-mut.html"><strong aria-hidden="true">2.6.</strong> IterMut</a></li><li class="chapter-item expanded "><a href="second-final.html"><strong aria-hidden="true">2.7.</strong> Final Code</a></li></ol></li><li class="chapter-item expanded "><a href="third.html"><strong aria-hidden="true">3.</strong> A Persistent Stack</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="third-layout.html"><strong aria-hidden="true">3.1.</strong> Layout</a></li><li class="chapter-item expanded "><a href="third-basics.html"><strong aria-hidden="true">3.2.</strong> Basics</a></li><li class="chapter-item expanded "><a href="third-drop.html"><strong aria-hidden="true">3.3.</strong> Drop</a></li><li class="chapter-item expanded "><a href="third-arc.html"><strong aria-hidden="true">3.4.</strong> Arc</a></li><li class="chapter-item expanded "><a href="third-final.html"><strong aria-hidden="true">3.5.</strong> Final Code</a></li></ol></li><li class="chapter-item expanded "><a href="fourth.html"><strong aria-hidden="true">4.</strong> A Bad Safe Deque</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fourth-layout.html"><strong aria-hidden="true">4.1.</strong> Layout</a></li><li class="chapter-item expanded "><a href="fourth-building.html"><strong aria-hidden="true">4.2.</strong> Building</a></li><li class="chapter-item expanded "><a href="fourth-breaking.html"><strong aria-hidden="true">4.3.</strong> Breaking</a></li><li class="chapter-item expanded "><a href="fourth-peek.html"><strong aria-hidden="true">4.4.</strong> Peek</a></li><li class="chapter-item expanded "><a href="fourth-symmetry.html"><strong aria-hidden="true">4.5.</strong> Symmetric Cases</a></li><li class="chapter-item expanded "><a href="fourth-iteration.html"><strong aria-hidden="true">4.6.</strong> Iteration</a></li><li class="chapter-item expanded "><a href="fourth-final.html"><strong aria-hidden="true">4.7.</strong> Final Code</a></li></ol></li><li class="chapter-item expanded "><a href="fifth.html"><strong aria-hidden="true">5.</strong> An Ok Unsafe Queue</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fifth-layout.html"><strong aria-hidden="true">5.1.</strong> Layout</a></li><li class="chapter-item expanded "><a href="fifth-unsafe.html"><strong aria-hidden="true">5.2.</strong> Unsafe</a></li><li class="chapter-item expanded "><a href="fifth-basics.html"><strong aria-hidden="true">5.3.</strong> Basics</a></li><li class="chapter-item expanded "><a href="fifth-miri.html"><strong aria-hidden="true">5.4.</strong> Miri</a></li><li class="chapter-item expanded "><a href="fifth-stacked-borrows.html"><strong aria-hidden="true">5.5.</strong> Stacked Borrows</a></li><li class="chapter-item expanded "><a href="fifth-testing-stacked-borrows.html"><strong aria-hidden="true">5.6.</strong> Testing Stacked Borrows</a></li><li class="chapter-item expanded "><a href="fifth-layout-basics-redux.html"><strong aria-hidden="true">5.7.</strong> Layout + Basics Redux</a></li><li class="chapter-item expanded "><a href="fifth-extras.html"><strong aria-hidden="true">5.8.</strong> Extras</a></li><li class="chapter-item expanded "><a href="fifth-final.html"><strong aria-hidden="true">5.9.</strong> Final Code</a></li></ol></li><li class="chapter-item expanded "><a href="sixth.html"><strong aria-hidden="true">6.</strong> A Production Unsafe Deque</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="sixth-layout.html"><strong aria-hidden="true">6.1.</strong> Layout</a></li><li class="chapter-item expanded "><a href="sixth-variance.html"><strong aria-hidden="true">6.2.</strong> Variance and Subtyping</a></li><li class="chapter-item expanded "><a href="sixth-basics.html"><strong aria-hidden="true">6.3.</strong> Basics</a></li><li class="chapter-item expanded "><a href="sixth-panics.html"><strong aria-hidden="true">6.4.</strong> Panic Safety</a></li><li class="chapter-item expanded "><a href="sixth-combinatorics.html"><strong aria-hidden="true">6.5.</strong> Boring Combinatorics</a></li><li class="chapter-item expanded "><a href="sixth-random-bits.html"><strong aria-hidden="true">6.6.</strong> Filling In Random Bits</a></li><li class="chapter-item expanded "><a href="sixth-testing.html"><strong aria-hidden="true">6.7.</strong> Testing</a></li><li class="chapter-item expanded "><a href="sixth-send-sync.html"><strong aria-hidden="true">6.8.</strong> Send, Sync, and Compile Tests</a></li><li class="chapter-item expanded "><a href="sixth-cursors-intro.html"><strong aria-hidden="true">6.9.</strong> An Introduction To Cursors</a></li><li class="chapter-item expanded "><a href="sixth-cursors-impl.html"><strong aria-hidden="true">6.10.</strong> Implementing Cursors</a></li><li class="chapter-item expanded "><a href="sixth-cursors-testing.html"><strong aria-hidden="true">6.11.</strong> Testing Cursors</a></li><li class="chapter-item expanded "><a href="sixth-final.html"><strong aria-hidden="true">6.12.</strong> Final Code</a></li></ol></li><li class="chapter-item expanded "><a href="infinity.html"><strong aria-hidden="true">7.</strong> A Bunch of Silly Lists</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="infinity-double-single.html"><strong aria-hidden="true">7.1.</strong> The Double Single</a></li><li class="chapter-item expanded "><a href="infinity-stack-allocated.html"><strong aria-hidden="true">7.2.</strong> The Stack-Allocated Linked List</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Learning Rust With Entirely Too Many Linked Lists æ—¥æœ¬èªç‰ˆ</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/rust-unofficial/too-many-lists" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- # Pop -->
<h1><a class="header" href="#pop-ãƒ¡ã‚½ãƒƒãƒ‰" id="pop-ãƒ¡ã‚½ãƒƒãƒ‰">Pop ãƒ¡ã‚½ãƒƒãƒ‰</a></h1>
<!-- Like `push`, `pop` wants to mutate the list. Unlike `push`, we actually
want to return something. But `pop` also has to deal with a tricky corner
case: what if the list is empty? To represent this case, we use the trusty
`Option` type: -->
<p><code>push</code> ã¨åŒæ§˜ï¼Œ<code>pop</code> ã¯ãƒªã‚¹ãƒˆã‚’å¤‰æ›´ã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ï¼
<code>push</code> ã¨ç•°ãªã‚‹ã¨ã“ã‚ã¯ï¼Œå®Ÿéš›ã«ä½•ã‹ã—ã‚‰ã®å€¤ã‚’è¿”ã™ã“ã¨ã§ã™ã­ï¼
<code>pop</code> ã¯ãƒªã‚¹ãƒˆãŒç©ºã ã£ãŸã‚‰ã©ã†ã™ã‚‹ã‹ã¨ã„ã†å„ä»‹ãªã‚³ãƒ¼ãƒŠãƒ¼ã‚±ãƒ¼ã‚¹ã‚‚æ‰±ã†å¿…è¦ãŒã‚ã‚Šã¾ã™ï¼
ã“ã®ã‚±ãƒ¼ã‚¹ã«å¯¾å‡¦ã™ã‚‹ãŸã‚ã«ï¼Œ<code>Option</code> å‹ã¨ã„ã†é ¼ã‚‚ã—ã„é“å…·ã‚’ä½¿ç”¨ã—ã¾ã™:</p>
<pre><code class="language-rust ignore">pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
    // TODO
}
</code></pre>
<!-- `Option<T>` is an enum that represents a value that may exist. It can either be
`Some(T)` or `None`. We could make our own enum for this like we did for
Link, but we want our users to be able to understand what the heck our return
type is, and Option is so ubiquitous that *everyone* knows it. In fact, it's so
fundamental that it's implicitly imported into scope in every file, as well
as its variants `Some` and `None` (so we don't have to say `Option::None`). -->
<p><code>Option&lt;T&gt;</code> ã¯å­˜åœ¨ã™ã‚‹ã‹ã©ã†ã‹ã‚ã‹ã‚‰ãªã„å€¤ã‚’æ‰±ã†åˆ—æŒ™å‹ã§ã™ï¼
<code>Some(T)</code> ã‹ <code>None</code> ã‹ã®ã„ãšã‚Œã‹ã®å€¤ã‚’å–ã‚Šã¾ã™ï¼
<code>Link</code> ã®ã¨ãã«ã‚„ã£ãŸã‚ˆã†ã«ç‹¬è‡ªã® <code>enum</code> ã‚’ä½œã£ã¦ã‚‚ã„ã„ã®ã§ã™ãŒï¼Œãƒ¦ãƒ¼ã‚¶ã«æˆ»ã‚Šå€¤ãŒä½•ãªã®ã‹ç†è§£ã—ã¦ã»ã—ã„ã®ã§ï¼Œ
ã©ã“ã«ã§ã‚‚ã‚ã‚Š <strong>èª°ã‚‚ãŒ</strong> çŸ¥ã£ã¦ã„ã‚‹ <code>Option</code> å‹ã‚’ä½¿ã†ã®ãŒå¾—ç­–ã§ã™ï¼
å®Ÿéš›ï¼Œ<code>Option</code> ã¯éå¸¸ã«åŸºæœ¬çš„ãªã‚‚ã®ãªã®ã§ï¼Œã™ã¹ã¦ã®ãƒ•ã‚¡ã‚¤ãƒ«ã§æš—é»™ã®ã†ã¡ã«ã‚¹ã‚³ãƒ¼ãƒ—ã«å–ã‚Šè¾¼ã¾ã‚Œã¾ã™ï¼
ãã®ãƒ´ã‚¡ãƒªã‚¢ãƒ³ãƒˆã§ã‚ã‚‹ <code>Some</code> ã‚„ <code>None</code> ã‚‚åŒæ§˜ã§ã™ï¼
(ã§ã™ã‹ã‚‰ï¼Œ<code>Option::None</code> ãªã©ã¨æ›¸ãå¿…è¦ã¯ãªã„ã®ã§ã™)</p>
<!-- The pointy bits on `Option<T>` indicate that Option is actually *generic* over
T. That means that you can make an Option for *any* type! -->
<p><code>Option&lt;T&gt;</code> ã® <code>&lt;T&gt;</code> ã¯ï¼Œ<code>Option</code> ãŒ <code>T</code> ã«å¯¾ã™ã‚‹ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã—ã¦ã„ã¾ã™ï¼
ã¤ã¾ã‚Šï¼Œã©ã‚“ãªå‹ã«å¯¾ã—ã¦ã‚‚ <code>Option</code> ã‚’ä½œã‚‹ã“ã¨ãŒã§ãã‚‹ã®ã§ã™ï¼</p>
<!-- So uh, we have this `Link` thing, how do we figure out if it's Empty or has
More? Pattern matching with `match`! -->
<p>ã•ã¦ï¼Œã“ã® <code>Link</code> ã§ã™ãŒï¼Œ<code>Empty</code> ã‹ <code>More</code> ã®ã©ã¡ã‚‰ãªã®ã‹ï¼Œã©ã†ã‚„ã£ã¦åˆ¤æ–­ã™ã‚Œã°ã„ã„ã§ã—ã‚‡ã†?
<code>match</code> ã§ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒã—ã¦ã¿ã¾ã™ã‹ï¼</p>
<pre><code class="language-rust ignore">pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
    match self.head {
        Link::Empty =&gt; {
            // TODO
        }
        Link::More(node) =&gt; {
            // TODO
        }
    };
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

error[E0308]: mismatched types
  --&gt; src/first.rs:27:30
   |
27 |     pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
   |            ---               ^^^^^^^^^^^ expected enum `std::option::Option`, found ()
   |            |
   |            this function's body doesn't return
   |
   = note: expected type `std::option::Option&lt;i32&gt;`
              found type `()`
</code></pre>
<!-- Whoops, `pop` has to return a value, and we're not doing that yet. We *could*
return `None`, but in this case it's probably a better idea to return
`unimplemented!()`, to indicate that we aren't done implementing the function.
`unimplemented!()` is a macro (`!` indicates a macro) that panics the program
when we get to it (\~crashes it in a controlled manner). -->
<p>ãŠã£ã¨ï¼Œ<code>pop</code> ã¯å€¤ã‚’è¿”ã•ãªã„ã¨ã„ã‘ãªã„ã®ã«ï¼Œã¾ã ã‚„ã£ã¦ã„ã¾ã›ã‚“ã§ã—ãŸã­ï¼
<code>None</code> ã‚’è¿”ã™ã“ã¨ã‚‚ã§ãã¾ã™ãŒï¼Œã“ã®å ´åˆï¼Œ
é–¢æ•°ã®å®Ÿè£…ãŒçµ‚ã‚ã£ã¦ã„ãªã„ã“ã¨ã‚’ç¤ºã™ãŸã‚ã« <code>unimplemented!()</code> ã‚’è¿”ã™æ–¹ãŒè‰¯ã„ã§ã—ã‚‡ã†ï¼
<code>unimplemented!()</code> ã¯ãƒã‚¯ãƒ­ã§ (<code>!</code> ã¯ãƒã‚¯ãƒ­ã‚’è¡¨ã—ã¾ã™)ï¼Œã“ã‚Œã«åˆ°é”ã™ã‚‹ã¨ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒãƒ‘ãƒ‹ãƒƒã‚¯ã—ã¾ã™ï¼
(ãƒ‘ãƒ‹ãƒƒã‚¯ã¨ã¯ï¼Œåˆ¶å¾¡ã•ã‚ŒãŸæ–¹æ³•ã§ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã•ã›ã‚‹ã“ã¨)ï¼</p>
<pre><code class="language-rust ignore">pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
    match self.head {
        Link::Empty =&gt; {
            // TODO
        }
        Link::More(node) =&gt; {
            // TODO
        }
    };
    unimplemented!()
}
</code></pre>
<!-- Unconditional panics are an example of a [diverging function][diverging].
Diverging functions never return to the caller, so they may be used in places
where a value of any type is expected. Here, `unimplemented!()` is being
used in place of a value of type `Option<T>`. -->
<p>ç„¡æ¡ä»¶ã®ãƒ‘ãƒ‹ãƒƒã‚¯ã¯ï¼Œç™ºæ•£ã™ã‚‹é–¢æ•° (<a href="https://doc.rust-lang.org/nightly/book/ch19-04-advanced-types.html#the-never-type-that-never-returns">diverging function</a>) ã®ä¾‹ã§ã™ï¼
ç™ºæ•£ã™ã‚‹é–¢æ•°ã¯å‘¼ã³å‡ºã—å…ƒã«æˆ»ã‚‹ã“ã¨ãŒãªã„ã®ã§ï¼Œæœ¬æ¥æœŸå¾…ã•ã‚Œã‚‹å€¤ã®å‹ãŒãªã‚“ã§ã‚ã£ãŸã¨ã—ã¦ã‚‚ï¼Œ
ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ï¼
ã“ã“ã§ã¯ï¼Œ<code>Option&lt;T&gt;</code> å‹ã®ä»£ã‚ã‚Šã« <code>unimplemented!()</code> ã‚’ä½¿ç”¨ã—ã¦ã„ã¾ã™ï¼</p>
<!-- Note also that we don't need to write `return` in our program. The last
expression (basically line) in a function is implicitly its return value. This
lets us express really simple things a bit more concisely. You can always
explicitly return early with `return` like any other C-like language. -->
<p>ã¾ãŸï¼Œãƒ—ãƒ­ã‚°ãƒ©ãƒ ä¸­ã« <code>return</code> ã‚’æ›¸ãå¿…è¦ã¯ãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ï¼
é–¢æ•°ã®æœ€å¾Œã®å¼ (åŸºæœ¬çš„ã«ã¯è¡Œ) ãŒï¼Œæš—é»™ã®ã†ã¡ã«æˆ»ã‚Šå€¤ã«ãªã‚Šã¾ã™ï¼
ã“ã‚Œã«ã‚ˆã£ã¦ï¼Œã™ã”ãå˜ç´”ãªé–¢æ•°ã‚’ã•ã‚‰ã«å˜ç´”ã«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ï¼
ä»–ã® C ç³»ã®è¨€èªã¨åŒæ§˜ã«ï¼Œ<code>return</code> ã§æ—©ã‚ã«å€¤ã‚’æ˜ç¤ºçš„ã«è¿”ã™ã“ã¨ã‚‚ã§ãã¾ã™ï¼</p>
<pre><code class="language-text">&gt; cargo build

error[E0507]: cannot move out of borrowed content
  --&gt; src/first.rs:28:15
   |
28 |         match self.head {
   |               ^^^^^^^^^
   |               |
   |               cannot move out of borrowed content
   |               help: consider borrowing here: `&amp;self.head`
...
32 |             Link::More(node) =&gt; {
   |                        ---- data moved here
   |
note: move occurs because `node` has type `std::boxed::Box&lt;first::Node&gt;`, which does not implement the `Copy` trait
  --&gt; src/first.rs:32:24
   |
32 |             Link::More(node) =&gt; {
   |                        ^^^^
</code></pre>
<!-- Come on Rust, get off our back! As always, Rust is hella mad at us. Thankfully,
this time it's also giving us the full scoop! By default, a pattern match will
try to move its contents into the new branch, but we can't do this because we
don't own self by-value here. -->
<p>ãŠã„ Rust, ä¿ºãŸã¡ã®é‚ªé­”ã‚’ã™ã‚‹ãªï¼
ã„ã¤ã‚‚ã®ã‚ˆã†ã«ï¼ŒRust ãŒã‚«ãƒ³ã‚«ãƒ³ã«èµ·ã“ã£ã¦ã„ã¾ã™ï¼
ã§ã‚‚ä»Šå›ã¯ã¡ã‚ƒã‚“ã¨ç†ç”±ã‚’æ•™ãˆã¦ãã‚Œã¾ã—ãŸï¼
ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ï¼Œãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒã¯ä¸­èº«ã‚’æ–°ã—ã„ãƒ–ãƒ©ãƒ³ãƒã«ãƒ ãƒ¼ãƒ–ã—ã‚ˆã†ã¨ã—ã¾ã™ãŒï¼Œ
ã“ã“ã§ã¯ <code>self</code> ã‚’å€¤ã¨ã—ã¦æ‰€æœ‰ã—ã¦ã„ãªã„ãŸã‚ï¼Œã“ã‚ŒãŒè¡Œãˆãªã„ã®ã§ã™ï¼</p>
<!-- ```text
help: consider borrowing here: `&self.head`
``` -->
<pre><code class="language-text">help: consider borrowing here: `&amp;self.head`

ãƒ˜ãƒ«ãƒ—: å€Ÿç”¨ã™ã‚‹ã“ã¨ã‚’æ¤œè¨ã—ã¦ã¿ã¦ãã ã•ã„: `&amp;self.head`
</code></pre>
<!-- Rust says we should add a reference to our `match` to fix that. ğŸ¤·â€â™€ï¸ Let's try it: -->
<p>Rust ãŒè¨€ã†ã«ã¯ï¼Œ<code>match</code> ã‚’å‚ç…§ã«ã™ã‚Œã°ç›´ã‚‹ã¿ãŸã„ã§ã™ã­ï¼ğŸ¤·â€â™€ï¸
è©¦ã—ã¦ã¿ã¾ã—ã‚‡ã†:</p>
<pre><code class="language-rust ignore">pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
    match &amp;self.head {
        Link::Empty =&gt; {
            // TODO
        }
        Link::More(node) =&gt; {
            // TODO
        }
    };
    unimplemented!()
}
</code></pre>
<pre><code class="language-text">&gt; cargo build

warning: unused variable: `node`
  --&gt; src/first.rs:32:24
   |
32 |             Link::More(node) =&gt; {
   |                        ^^^^ help: consider prefixing with an underscore: `_node`
   |
   = note: #[warn(unused_variables)] on by default

warning: field is never used: `elem`
  --&gt; src/first.rs:13:5
   |
13 |     elem: i32,
   |     ^^^^^^^^^
   |
   = note: #[warn(dead_code)] on by default

warning: field is never used: `next`
  --&gt; src/first.rs:14:5
   |
14 |     next: Link,
   |     ^^^^^^^^^^
</code></pre>
<!-- Hooray, compiling again! Now let's figure out that logic. We want to make an
Option, so let's make a variable for that. In the Empty case we need to return
None. In the More case we need to return `Some(i32)`, and change the head of
the list. So, let's try to do basically that? -->
<p>ä¸‡æ­³ï¼Œã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ãŒé€šã£ãŸãï¼
ãã‚Œã§ã¯ï¼ŒTODO ã§æ®‹ã—ã¦ãŠã„ãŸãƒ­ã‚¸ãƒƒã‚¯éƒ¨åˆ†ã‚’è€ƒãˆã¦ã„ãã¾ã—ã‚‡ã†ï¼
<code>Option</code> ã‚’ä½œã‚ŠãŸã„ã®ã§ï¼Œãã®ãŸã‚ã®å¤‰æ•°ã‚’ä½œã‚Šã¾ã™ï¼
<code>Empty</code> ã®å ´åˆã«ã¯ <code>None</code> ã‚’è¿”ã•ãªã„ã¨ã„ã‘ã¾ã›ã‚“ã­ï¼
<code>More</code> ã®å ´åˆã«ã¯ <code>Some(i32)</code> ã‚’è¿”ã—ã¦ï¼Œãƒªã‚¹ãƒˆã®å…ˆé ­ã‚’å¤‰æ›´ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ï¼
ãŠãŠã¾ã‹ã«ã¯ã“ã‚“ãªæ„Ÿã˜ã§ã©ã†ã§ã—ã‚‡ã†ã‹ï¼Ÿ</p>
<pre><code class="language-rust ignore">pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
    let result;
    match &amp;self.head {
        Link::Empty =&gt; {
            result = None;
        }
        Link::More(node) =&gt; {
            result = Some(node.elem);
            self.head = node.next;
        }
    };
    result
}
</code></pre>
<pre><code class="language-text">&gt; cargo build
   Compiling lists v0.1.0 (/Users/ABeingessner/dev/temp/lists)
error[E0507]: cannot move out of borrowed content
  --&gt; src/first.rs:35:29
   |
35 |                 self.head = node.next;
   |                             ^^^^^^^^^ cannot move out of borrowed content

</code></pre>
<!-- *head*

*desk* -->
<p>ã‚´ãƒ³ï¼(é ­ã‚’æœºã«å©ãã¤ã‘ãŸéŸ³)</p>
<!-- We're trying to move out of `node` when all we have is a shared reference to it. -->
<p>å…±æœ‰å‚ç…§ã—ã¦ã„ã‚‹ã‚‚ã®ã‚’ï¼Œ<code>node</code> ã‹ã‚‰ãƒ ãƒ¼ãƒ–ã—ã‚ˆã†ã¨ã—ã¦ã—ã¾ã£ãŸã‚ˆã†ã§ã™ï¼</p>
<!-- We should probably step back and think about what we're trying to do. We want
to: -->
<p>ç«‹ã¡æ­¢ã¾ã£ã¦ï¼Œã“ã‚Œã‹ã‚‰ã‚„ã‚ã†ã¨ã—ã¦ã„ã‚‹ã“ã¨ãŒä½•ãªã®ã‹è€ƒãˆç›´ã™ã¹ãã§ã—ã‚‡ã†ï¼
ç§ãŸã¡ãŒã‚„ã‚ŠãŸã„ã®ã¯æ¬¡ã®ã‚ˆã†ãªã“ã¨ã§ã™:</p>
<!-- * Check if the list is empty.
* If it's empty, just return None
* If it's *not* empty
    * remove the head of the list
    * remove its `elem`
    * replace the list's head with its `next`
    * return `Some(elem)` -->
<ul>
<li>ãƒªã‚¹ãƒˆãŒç©ºã‹ã©ã†ã‹ãƒã‚§ãƒƒã‚¯ã™ã‚‹</li>
<li>ç©ºã§ã‚ã‚Œã°ï¼Œ<code>None</code> ã‚’è¿”ã›ã°ã„ã„ã§ã™</li>
<li>ç©ºã§ãªã‹ã£ãŸã¨ãã¯ä»¥ä¸‹ã‚’å®Ÿè¡Œã—ã¾ã™:
<ul>
<li>ãƒªã‚¹ãƒˆã®å…ˆé ­ã‚’å‰Šé™¤ã™ã‚‹</li>
<li><code>elem</code> ã‚’å‰Šé™¤ã™ã‚‹</li>
<li>ãƒªã‚¹ãƒˆã®å…ˆé ­ã‚’ <code>next</code> ã§ç½®ãæ›ãˆã‚‹</li>
<li><code>Some(elem)</code> ã‚’è¿”ã™</li>
</ul>
</li>
</ul>
<!-- The key insight is we want to *remove* things, which means we want to get the
head of the list *by value*. We certainly can't do that through the shared
reference we get through `&self.head`. We also "only" have a mutable reference
to `self`, so the only way we can move stuff is to *replace it*. Looks like we're doing
the Empty dance again! -->
<p>é‡è¦ãªã“ã¨ã¯ï¼Œç§ãŸã¡ãŒ <strong>å‰Šé™¤</strong> ã‚’ã—ã‚ˆã†ã¨ã—ã¦ã„ã‚‹ã¨ã„ã†ç‚¹ã§ã™ï¼
ã“ã‚Œã¯ã¤ã¾ã‚‹ã¨ã“ã‚ãƒªã‚¹ãƒˆã®å…ˆé ­ã‚’ï¼ˆæ‰€æœ‰æ¨©ã®ã‚ã‚‹ï¼‰å€¤ã¨ã—ã¦å–å¾—ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ï¼
å…±æœ‰å‚ç…§ã§ã‚ã‚‹ <code>&amp;self.head</code> ã§ã¯ï¼Œãã‚“ãªã“ã¨ã¯ã§ãã¾ã›ã‚“ï¼
ã•ã‚‰ã« <code>self</code> ã¸ã®å‚ç…§ã¯æ—¢ã«ã‚ã‚‹å¯å¤‰å‚ç…§ã€Œã ã‘ã€ãªã®ã§ï¼Œãƒ ãƒ¼ãƒ–ã™ã‚‹ã«ã¯ç½®ãæ›ãˆã‚‹ã—ã‹ã‚ã‚Šã¾ã›ã‚“ï¼
ã©ã†ã‚„ã‚‰ï¼Œã¾ãŸæˆ‘ã€…ã¯ Empty ãƒ€ãƒ³ã‚¹ã‚’ã—ã¦ã„ã‚‹ã‚ˆã†ã§ã™ï¼</p>
<!-- Let's try that: -->
<p>è©¦ã—ã¦ã¿ã¾ã—ã‚‡ã†:</p>
<pre><code class="language-rust ignore">pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
    let result;
    match mem::replace(&amp;mut self.head, Link::Empty) {
        Link::Empty =&gt; {
            result = None;
        }
        Link::More(node) =&gt; {
            result = Some(node.elem);
            self.head = node.next;
        }
    };
    result
}
</code></pre>
<pre><code class="language-text">cargo build

   Finished dev [unoptimized + debuginfo] target(s) in 0.22s
</code></pre>
<!-- O M G -->
<p>ã‚ã‚Šãˆãªã„â€¦ï¼</p>
<!-- It compiled without *any* warnings!!!!! -->
<p>è­¦å‘Šã‚’ <strong>ã²ã¨ã¤ã‚‚</strong> å‡ºã•ãšã«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã§ãã¾ã—ãŸ!!!!!</p>
<!-- Actually I'm going to apply my own personal lint here: we made this `result`
value to return, but actually we didn't need to do that at all! Just as a
function evaluates to its last expression, every block also evaluates to
its last expression. Normally we supress this behaviour with semi-colons,
which instead makes the block evaluate to the empty tuple, `()`. This is
actually the value that functions which don't declare a return value -- like
`push` -- return. -->
<p>å€‹äººçš„ãªã“ã ã‚ã‚Šã§ã™ãŒï¼Œã“ã“ã§ã‚³ãƒ¼ãƒ‰æ•´å½¢ã‚’ã—ã¾ã—ã‚‡ã†: <code>result</code> ã¨ã„ã†å¤‰æ•°ã‚’ä½¿ã„ã¾ã—ãŸãŒï¼Œå®Ÿã¯ã“ã‚Œã¯ä¸è¦ã§ã™ï¼
é–¢æ•°ãŒæœ€å¾Œã®å¼ã§è©•ä¾¡ã•ã‚Œã‚‹ã®ã¨åŒã˜ã‚ˆã†ã«ï¼Œ<code>match</code> ã®å„ãƒ–ãƒ­ãƒƒã‚¯ã‚‚æœ€å¾Œã®å¼ã§è©•ä¾¡ã•ã‚Œã¾ã™ï¼
é€šå¸¸ã¯ã‚»ãƒŸã‚³ãƒ­ãƒ³ã‚’ä»˜ã‘ã¦æ–‡ã«ã™ã‚‹ã“ã¨ã§ã“ã®æŒ™å‹•ã‚’æŠ‘åˆ¶ã—ï¼Œãƒ–ãƒ­ãƒƒã‚¯ã®è©•ä¾¡ã‚’ç©ºã®ã‚¿ãƒ—ãƒ« <code>()</code> ã«ã—ã¾ã™ã­ï¼
ã“ã® <code>()</code> ã¯ <code>push</code> ã®ã‚ˆã†ã«æˆ»ã‚Šå€¤ã‚’å®£è¨€ã—ãªã„é–¢æ•°ã®è¿”ã‚Šå€¤ã§ã™ï¼</p>
<!-- So instead, we can write `pop` as: -->
<p>ãã“ã§ï¼Œä»£ã‚ã‚Šã« <code>pop</code> ã‚’ã“ã†æ›¸ãã“ã¨ãŒã§ãã¾ã™:</p>
<pre><code class="language-rust ignore">pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
    match mem::replace(&amp;mut self.head, Link::Empty) {
        Link::Empty =&gt; None,
        Link::More(node) =&gt; {
            self.head = node.next;
            Some(node.elem)
        }
    }
}
</code></pre>
<!-- Which is a bit more concise and idiomatic. Note that the Link::Empty branch
completely lost its braces, because we only have one expression to
evaluate. Just a nice shorthand for simple cases. -->
<p>ã‚ˆã‚Šç°¡æ½”ã§æ…£ç”¨çš„ãªã‚³ãƒ¼ãƒ‰ã«ãªã‚Šã¾ã—ãŸï¼
<code>Link::Empty</code> ãƒ–ãƒ©ãƒ³ãƒã§ã¯ï¼Œä¸­æ‹¬å¼§ <code>{}</code> ãŒå®Œå…¨ã«å¤±ã‚ã‚Œã¦ã„ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ï¼
è©•ä¾¡ã™ã‚‹å¼ãŒï¼‘ã¤ã—ã‹ãªã„ã¨ãã«ã¯çœç•¥ã§ãã‚‹ã‚“ã§ã™ï¼</p>
<pre><code class="language-text">cargo build

   Finished dev [unoptimized + debuginfo] target(s) in 0.22s
</code></pre>
<!-- Nice, still works! -->
<p>ã¡ã‚ƒã‚“ã¨ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚‚é€šã‚Šã¾ã—ãŸï¼ã„ã„ã­ï¼</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="first-push.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="first-test.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="first-push.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="first-test.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
